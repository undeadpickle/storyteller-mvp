# StoryTeller MVP - Product Requirements Document (v1.2 - Dynamic Generation Focused)

**Version:** 1.2
**Date:** March 26, 2025

**MVP Scope Consideration:** _This version incorporates dynamic story generation via a Text LLM. This represents a significant increase in scope, complexity, risk, cost, and timeline compared to v1.1 (which used pre-written content). Feasibility within an MVP timeframe needs careful evaluation. Robust safety measures are paramount._

## 1. Product Overview

- **Expanded Vision:** StoryTeller aims to foster imagination and early literacy skills in young children (4-10) by providing engaging, interactive audio-visual stories **dynamically generated by AI**, narrated with expressive voice.
- **Core Loop:** Child selects profile -> Initiates story (e.g., via prompt/theme) -> **Waits for generation** -> Listens to AI-generated narration & views visuals -> Makes AI-generated choices -> **Waits for generation** -> Continues story -> Completes story -> Answers dynamically generated comprehension questions -> Returns to selection/initiation.

## 2. Target Audience

- **Children (4-10):** Requires extremely intuitive interface to handle story initiation and patient handling of loading/generation times. **Content safety and age-appropriateness are critical.**
- **Parents:** Involved in initial setup. Need awareness of the generative nature and potential variability of stories. May need simple safety controls or reporting mechanisms (Post-MVP).

## 3. Core MVP Features

### 3.1 Dynamic Content Generation

- **Story Source:** Text Generation LLM (e.g., Google AI Gemini API) generates story narratives and branching choices in real-time or near real-time.
- **Initiation:** Define MVP method (Theme selection recommended for simplicity).
- **Branching Narratives:** LLM generates 2-3 relevant choices at logical pause points.
- **Story Structure:** Requires sophisticated prompt engineering for coherence, age-appropriateness, length, and choice points.
- **Comprehension Questions:** LLM dynamically generates 1-2 simple questions based on the specific story segment.

### 3.2 Voice Narration

- **Source:** ElevenLabs API generates voice narration from LLM text output.
- **Tones:** Attempt to guide contextually (Cheerful, Mysterious, Calm).
- **Workflow:** Orchestrate API calls: `Story Initiation -> Text LLM (Segment + Choices) -> ElevenLabs (Audio) -> Present to User`.
- **Control:** Simple playback speed control (0.8x, 1x, 1.2x).

### 3.3 User Experience (UX)

- **Interface:** Simple, visual, large touch targets. **Must include clear loading indicators.**
- **Story Initiation:** Simple UI for theme selection (or prompt input).
- **Story Player:** Basic visuals (theme-based), Play/Pause, progress (approximate), choice buttons.
- **Interactions:** Tap-based, tolerant of loading delays.
- **Safety:** **Critical.** Input filtering (if prompts), prompt engineering for safety, output filtering, API safety settings.

### 3.4 User Management (Local Profiles)

- **Authentication:** **No user authentication.**
- **Profiles:** Up to 3 local profiles per device/browser.
- **Creation/Selection:** Simple name + avatar.
- **Progress Tracking:** Minimal MVP scope: Save initiating prompt/theme and completion status via `localStorage`. Saving full state is high risk/complexity.

## 4. Technical Requirements

### 4.1 Platform & Development Environment

- **Core:** React (`latest`), Vite (`latest`), Node.js (`latest` LTS), npm/yarn.
- **Language:** JavaScript or TypeScript.

### 4.2 State Management

- **Primary:** Zustand (`latest`) recommended.

### 4.3 Styling

- Tailwind CSS with shadcn/ui component system.

### 4.4 API Integrations

- **Voice Generation:** ElevenLabs API service module (`src/services/elevenlabs.js`).
- **Text Generation:** Google AI Gemini API service module (`src/services/storyGenerator.js`).
- **API Orchestration:** Logic (`src/hooks/useStoryEngine.js`?) to manage sequence, loading states, errors.
- **Keys:** Via `.env` (`VITE_ELEVENLABS_API_KEY`, `VITE_GEMINI_API_KEY`).

### 4.5 Storage

- **Primary:** Browser `localStorage` for profiles and minimal progress state.

### 4.6 Accessibility

- Semantic HTML, WCAG contrast, keyboard navigation, screen reader support, large targets.

### 4.7 Prompt Engineering & Safety

- **Requirement:** Dedicated effort for prompt design, testing, refinement.
- **Goals:** Age-appropriateness, coherence, engagement, choice generation, safety compliance.
- **Implementation:** Utilize API safety features, consider input/output filters.

## 5. Code Structure & Data Models

### 5.1 Folder Structure (Suggestion)

- Standard React structure (`assets`, `components`, `hooks`, `services`, `store`, `styles`, `prompts`).

### 5.2 Naming Conventions & Component Style

- PascalCase components, camelCase variables/functions, Functional components + Hooks.

### 5.3 Data Models (Dynamic)

- Define interfaces/types for `UserProfile`, `StorySegment` (dynamic output from LLM), `StoryChoice`, dynamic `ComprehensionQuestion`, `AppState`, and `localStorage` structure (minimal).

## 6. Out of Scope for MVP

- Pre-written stories (as primary content source)
- User Authentication & Accounts
- Database / Backend Storage & Cross-device Sync
- User-generated content (beyond initial prompts/themes)
- Mobile native apps
- Offline capabilities
- Monetization features
- Detailed parent dashboard/controls
- Dynamic Image Generation

## 7. Success Metrics

- User Engagement: Session Duration, Return Usage Rate.
- Generation Quality: Coherence, choice relevance, age-appropriateness (assessment needed).
- Task Success: Story completion rate, comprehension success rate.
- Technical: API error rates, average generation latency.

## 8. Development Timeline & Risks

- **Timeline:** **24+ weeks** estimated for MVP due to high complexity. Requires reassessment after Phase 1.
- **Potential Risks:** Latency (High), Cost (High), Content Safety/Appropriateness (Very High), Generation Quality/Consistency, Prompt Engineering Difficulty, Scope Creep, Storage Limitations.
- **Mitigations:** Early PoC for core loop, strict safety focus, cost monitoring, simplify initiation/scope, manage expectations, be ready to pivot.

## 9. Development Phases (Sequential)

- **Phase 0: Project Setup & Core Dependencies**

  - Initialize project using Vite/React.
  - Set up tooling (linters, formatters).
  - Install core libraries (React, Zustand, styling solution).
  - Set up basic Git repository.
  - **Goal:** Establish a clean, working project foundation.

- **Phase 1: Core Generation PoC (Proof of Concept)**

  - Implement basic service modules for Gemini API and ElevenLabs API.
  - Create minimal logic to: Send a hardcoded initial prompt -> Get one text segment from Gemini -> Send text segment to ElevenLabs -> Receive audio -> Play audio using HTML5 Audio element.
  - No UI integration beyond basic triggering/logging. Minimal error handling.
  - **Goal:** Validate technical feasibility of the core AI chain and get preliminary latency/cost/quality data. **Crucial risk mitigation step.**

- **Phase 2: Basic Story Loop & UI Shell**

  - Build basic UI components: `StoryPlayer`, loading indicators, simple Play/Pause.
  - Integrate Phase 1 PoC logic into a basic UI flow.
  - Implement state management (Zustand) for loading states, current text, audio source.
  - Implement simple story initiation (e.g., button triggers hardcoded theme/prompt).
  - Focus on displaying one segment + playing audio, then stopping (no choices yet).
  - **Goal:** Get a rudimentary, non-interactive story segment playing within the basic app structure.

- **Phase 3: Dynamic Choices & State Management**

  - Refine Gemini prompts to request story continuation _and_ 2-3 choices (e.g., in JSON format).
  - Update `StoryGeneratorService` to parse choices from the LLM response.
  - Implement `ChoiceButton` component and display dynamic choices in the `StoryPlayer` UI.
  - Enhance state management (`useStoryEngine` hook?) to handle choice selection.
  - Implement logic: User clicks choice -> Send choice context to Gemini for next segment -> Repeat loop.
  - **Goal:** Achieve the core interactive branching narrative loop based on AI-generated choices.

- **Phase 4: Profile Management & Persistence**

  - Implement UI for creating/selecting up to 3 local user profiles (name + avatar).
  - Implement `localStorage` service to save/load profiles.
  - Integrate profile selection into the app startup flow.
  - Implement minimal progress saving to `localStorage` (e.g., save initiating prompt/theme when a story starts, mark as complete).
  - **Goal:** Add basic multi-user capability and minimal persistence.

- **Phase 5: Comprehension Questions & Polish**

  - Refine Gemini prompts to generate 1-2 comprehension questions based on the _last_ story segment.
  - Implement UI to display question and multiple-choice answers after a story ends.
  - Add basic feedback for correct/incorrect answers.
  - Refine overall UI/UX based on previous phases (animations, layout, better error handling).
  - Implement basic accessibility features (keyboard nav, ARIA).
  - **Goal:** Complete the core feature set and improve overall presentation.

- **Phase 6: Safety, Testing & Deployment Prep**
  - Implement and rigorously test all safety measures (prompt design, API settings, filtering).
  - Conduct usability testing with target age group (focus on flow, comprehension, latency tolerance).
  - Perform cross-browser testing.
  - Code cleanup, final documentation.
  - Set up build process for deployment.
  - **Goal:** Ensure MVP is stable, reasonably safe, usable, and ready for initial launch.

## 10. AI Assistant Prompts (Examples - Updated)

```bash
# Setup (Similar, specify Zustand if chosen)
"Set up a new React project using Vite (`latest`), Node LTS (`latest`), Zustand, and CSS Modules."

# API Services
"Create the `ElevenLabsService` using `Workspace`..."
"Create the `StoryGeneratorService` using `Workspace` to call the Google AI Gemini API (`generateContent` method). Include functions for generating initial story segments, continuations based on choices, and comprehension questions. Handle API key via env vars. Implement basic safety settings."
"Create a `src/prompts` directory and draft initial prompt templates for story initiation (theme-based) and continuation (requesting text + 3 choices as JSON)."

# Core Logic
"Create a custom hook `useStoryEngine` in `src/hooks` that manages:
  - Current story state (segment text, choices, loading status, errors).
  - Orchestrating calls to `StoryGeneratorService` and `ElevenLabsService`.
  - Updating state based on API responses and user choices."

# Components
"Implement the `StoryInitiation` component (using pre-defined themes)."
"Update the `StoryPlayer` component to use `useStoryEngine`, display dynamic text/choices, and show loading indicators."
"Implement basic `localStorage` functions to save/load profiles and the *initiating prompt/theme* for started stories."
```
